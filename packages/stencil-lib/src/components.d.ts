/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { DateChange } from "./components/inno-date-context-api/inno-date-api";
import { DragAndDropTexts } from "./components/inno-drag-and-drop/drag-and-drop-texts";
import { InnoModalSize } from "./components/inno-modal/inno-modal.model";
import { ExpandedChangedEvent } from "./components/inno-pane/inno-pane";
import { Placement } from "@floating-ui/dom";
import { InnoStatusMessageConfig, InnoStatusMessagePosition, InnoStatusMessageTheme, InnoStatusMessageType, ShowStatusMessageResult } from "./components/inno-status-message/inno-status-message.api";
import { TabClickDetail } from "./components/inno-tab-item/inno-tab-item";
import { InnoTimePickerTexts } from "./components/inno-time-picker/inno-time-picker.api";
export { DateChange } from "./components/inno-date-context-api/inno-date-api";
export { DragAndDropTexts } from "./components/inno-drag-and-drop/drag-and-drop-texts";
export { InnoModalSize } from "./components/inno-modal/inno-modal.model";
export { ExpandedChangedEvent } from "./components/inno-pane/inno-pane";
export { Placement } from "@floating-ui/dom";
export { InnoStatusMessageConfig, InnoStatusMessagePosition, InnoStatusMessageTheme, InnoStatusMessageType, ShowStatusMessageResult } from "./components/inno-status-message/inno-status-message.api";
export { TabClickDetail } from "./components/inno-tab-item/inno-tab-item";
export { InnoTimePickerTexts } from "./components/inno-time-picker/inno-time-picker.api";
export namespace Components {
    interface InnoAccordion {
        /**
          * You can programatically open/close the accordion with this property.
         */
        "collapsed": boolean;
        /**
          * Whether it is an accordion inside another accordion. Gives a different style then the main one.
         */
        "inner": boolean;
        /**
          * Text to display for the accordion. Always visible whether the accordion is opened or closed.
         */
        "label": string;
        /**
          * Whether the accordion is the last in a group of accordions. Needed for styling.
         */
        "last": boolean;
        /**
          * Secondary text for the accordion. Always visible whether the accordion is opened or closed.
         */
        "secondLabel": string;
        /**
          * Color variant of the accordion.
         */
        "variant": 'light' | 'dark';
    }
    interface InnoBreadcrumb {
        /**
          * Color variant of the accordion.
         */
        "variant": 'light' | 'dark';
    }
    interface InnoBreadcrumbItem {
        /**
          * Icon to be displayed next ot the label
         */
        "icon": string;
        "iconSize": number;
        "itemIndex": number;
        /**
          * Breadcrumb label
         */
        "label": string;
        "showChevron": boolean;
        "visible": boolean;
    }
    interface InnoButton {
        /**
          * Color variant of the button.
         */
        "colorVariant": 'light' | 'dark';
        /**
          * Whether the button is disabled or not.
         */
        "disabled": boolean;
        /**
          * Icon to use inside the button.
         */
        "icon": string;
        /**
          * Only show an icon.
         */
        "iconOnly": boolean;
        /**
          * Where to put the icon relative to the text.
         */
        "iconPosition": 'left' | 'right';
        /**
          * Special style for button lists.
         */
        "listType": boolean;
        /**
          * Direction of the navigation button. Only has effect if the variant is 'navigation'.
         */
        "navDirection": 'left' | 'right';
        /**
          * Tab index of the button.
         */
        "tabIdx": number;
        /**
          * Type of the button.
         */
        "type": 'button' | 'submit';
        /**
          * Variant of the button.
         */
        "variant": 'primary' | 'secondary' | 'tertiary' | 'media' | 'navigation' | 'delete';
    }
    /**
     * Checkbox for Innomatics design system.
     */
    interface InnoCheckbox {
        /**
          * Whether element is checked.
         */
        "checked": boolean | undefined;
        /**
          * Whether component is disabled. In this state no other state effects are applied to the element like error.
         */
        "disabled": boolean;
        /**
          * Whether the element is in error state. Error state can be defined if manual error handling is required.
         */
        "error": boolean;
        /**
          * Whether indeterminate state is enabled for the component. The component is in indeterminate state if it is explicity requested and the checked status is not defined
         */
        "indeterminate": boolean;
        /**
          * Label to show.
         */
        "label": string;
        /**
          * Form entry name.
         */
        "name": string;
        /**
          * Whether the component is readonly. In this state no other state effects are applied to the element like error.
         */
        "readonly": boolean;
        /**
          * Mark the component as required and show the required marker. Validation is performed with this property.
         */
        "required": boolean;
        /**
          * The tab index.
         */
        "tabIdx": number;
        /**
          * Theme variant of the component.
         */
        "variant": 'dark' | 'light';
    }
    /**
     * Innomotics date-picker.
     */
    interface InnoDatePicker {
        /**
          * Date format string. See "https://moment.github.io/luxon/#/formatting?id=table-of-tokens" for all available tokens.
         */
        "format": string;
        /**
          * The selected starting date. If the date-picker is not in range mode this is the selected date. Format has to match the `format` property.
         */
        "from": string | undefined;
        /**
          * Get the currently selected date-range.
         */
        "getCurrentDate": () => Promise<{ from: string; to: string; }>;
        /**
          * Text of date select button
         */
        "i18nDone": string;
        /**
          * Format of time string See "https://moment.github.io/luxon/#/formatting?id=table-of-tokens" for all available tokens.
         */
        "locale": string;
        /**
          * The latest date that can be selected by the date picker. If not set there will be no restriction.
         */
        "maxDate": string;
        /**
          * The earliest date that can be selected by the date picker. If not set there will be no restriction.
         */
        "minDate": string;
        /**
          * If true a date-range can be selected (from/to).
         */
        "range": boolean;
        /**
          * Show the days outside the selected month.
         */
        "showOuterDays": boolean;
        "standaloneAppearance": boolean;
        /**
          * The selected end date. If the date-picker is not in range mode this property has no impact. Format has to match the `format` property.
         */
        "to": string | undefined;
        "today": string;
        /**
          * The index of which day to start the week on, based on the Locale#weekdays array. E.g. if the locale is en-us, weekStartIndex = 1 results in starting the week on monday.
         */
        "weekStartIndex": number;
    }
    /**
     * Date-picker with dropdown.
     */
    interface InnoDatePickerDropdown {
        "closeOnSelection": boolean;
        /**
          * Date format string. See the date-picker component for more information.
         */
        "format": string;
        /**
          * The selected starting range. See the date-picker component for more information.
         */
        "from": string | undefined;
        /**
          * Label of the dropdown component.
         */
        "label": string | undefined;
        /**
          * Format of the date strings. See the date-picker component for more information.
         */
        "locale": string;
        /**
          * The latest date that can be selected by the date picker. See the date-picker component for more information.
         */
        "maxDate": string;
        /**
          * The earliest date that can be selected by the date picker. See the date-picker component for more information.
         */
        "minDate": string;
        /**
          * If true a date-range can be selected. See the date-picker component for more information.
         */
        "range": boolean;
        /**
          * Show the days outside the selected month. See the date-picker component for more information.
         */
        "showOuterDays": boolean;
        /**
          * The selected end date. See the date-picker component for more information.
         */
        "to": string | undefined;
        /**
          * Color variant of the component.
         */
        "variant": 'dark' | 'light';
        /**
          * The index of which day to start the week on. See the date-picker component for more information.
         */
        "weekStartIndex": number;
    }
    interface InnoDateTimeCard {
        "standaloneAppearance": boolean;
    }
    interface InnoDragAndDrop {
        /**
          * The accept attribute specifies the types of files that the server accepts (that can be submitted through a file upload). "https://www.w3schools.com/tags/att_input_accept.asp"
         */
        "accept": string;
        /**
          * Disable all input events
         */
        "disabled": boolean;
        /**
          * If multiple is true the user can drop or select multiple files
         */
        "multiple": boolean;
        "setFilesToUpload": (obj: any) => Promise<void>;
        /**
          * After a file is uploaded you can set the upload component to a defined state
         */
        "state": 'SELECT_FILE' | 'LOADING' | 'UPLOAD_FAILED' | 'UPLOAD_SUCCESS';
        /**
          * 'firstLineText' and 'secondLineText': will be used by state = 'SELECT_FILE', <br/><br/>'orText': The word 'or' or its equivalent translation. Hidden if only 'firstLineText' or only 'secondLineText' is used, <br/><br/>'dragText': displayed when file is dragged over the component, can be omitted, <br/><br/>'loadingText': will be used by state = 'LOADING', <br/><br/>'uploadFailedText': will be used by state = 'UPLOAD_FAILED', <br/><br/>'uploadSuccessText': will be used by state = 'UPLOAD_SUCCESS', <br/><br/>'acceptedFileTypesText': label for accepted file types, <br/><br/>'uploadDisabledText': label for disabled state
         */
        "texts": DragAndDropTexts;
        /**
          * Color variant of the component.
         */
        "variant": 'dark' | 'light';
    }
    interface InnoError {
        /**
          * Show the error or not.
         */
        "active": boolean;
        /**
          * The input's validation error type, see: https://developer.mozilla.org/en-US/docs/Web/API/ValidityState
         */
        "type": 'badInput' | 'customError' | 'patternMismatch' | 'rangeOverflow' | 'rangeUnderflow' | 'stepMismatch' | 'tooLong' | 'tooShort' | 'typeMismatch' | 'valid' | 'valueMissing' | undefined;
        /**
          * Theme variant of the input.
         */
        "variant": 'dark' | 'light';
    }
    /**
     * Represents the general footer for the Innomotics applications.
     */
    interface InnoFooter {
        /**
          * The copyright label.
         */
        "copyright": string;
        /**
          * Theme variant property.
         */
        "variant": 'light' | 'dark';
    }
    /**
     * Represents an inno-footer item.
     * Wrap an element for the inno-footer parent.
     * See the InnoFooter docs for more information.
     */
    interface InnoFooterItem {
        /**
          * Theme variant property. Inherited from the parent. Can be overridden if explicitly defined.
         */
        "variant": 'light' | 'dark';
    }
    interface InnoIcon {
        /**
          * The icon name. Use this or the iconFont property.
         */
        "icon": string;
        /**
          * Font icon code for the InnomoticsUiIcons font. Use this or the icon property.
         */
        "iconFont": string;
        "size": number;
        /**
          * Color style of the icon.
         */
        "variant": 'light' | 'dark';
    }
    interface InnoInput {
        /**
          * When you click on the inno-input a focus() command is called on the input element. This might cause that the caret position will be at the beginnging of the input's value. Set this to true if you want the caret position to be at the end. Only has an effect if the input type is 'text'. Has no effect if 'selectOnFocus' is also true.
         */
        "caretPosEndOnFocus": boolean;
        /**
          * The floating label is an absolutely positioned element meaning if it is too long it will grow out of the boundaries of the InnoInput component. By default the InnoInput component automatically resizes the floating label so it will fit inside. You can turn this behavior off e.g. if you are sure the label will always fit or it causes some issues.
         */
        "disableFloatingLabelAutoResize": boolean;
        /**
          * Whether the inno-input component is disabled or not. Probably not needed to be set since the component automatically detects if the inserted input element is disabled or not. The inno-input component will also be in a disabled state when the input element is readonly.
         */
        "disabled": boolean;
        /**
          * Error message to show. If you don't want to use this property you can manually add 'inno-error' components inside the 'inno-input' component. You can either use this property or use the manually added errors. Can't use both at the same time.
         */
        "error": string;
        /**
          * The input's validation error type, see: https://developer.mozilla.org/en-US/docs/Web/API/ValidityState <br/><br/>Only has an effect if 'error' has a value.
         */
        "errortype": | 'badInput'
    | 'customError'
    | 'patternMismatch'
    | 'rangeOverflow'
    | 'rangeUnderflow'
    | 'stepMismatch'
    | 'tooLong'
    | 'tooShort'
    | 'typeMismatch'
    | 'valid'
    | 'valueMissing'
    | undefined;
        /**
          * Whether the input is focused or not.
         */
        "isFocused": boolean;
        /**
          * Floating label for the input.
         */
        "label": string;
        /**
          * Set the resize direction. Only has effect if textarea is provided as wrapped element.
         */
        "resizeMode": 'vertical' | 'horizontal' | 'both';
        /**
          * Whether the textarea is resizeable. Only has effect if textarea is provided as wrapped element.
         */
        "resizeable": boolean;
        /**
          * When you click on the inno-input a focus() command is called on the input element. This might cause that the caret position will be at the beginnging of the input's value. Set this to true if you want to select all of the text by default.
         */
        "selectOnFocus": boolean;
        "valuePropReDefine": boolean;
        /**
          * Color variant of the input.
         */
        "variant": 'light' | 'dark';
    }
    interface InnoLoader {
        /**
          * Size of the loader. Valid values are: 16, 24, 32, 64.
         */
        "size": number;
        /**
          * Loader bar width.
         */
        "strokeWidth": 'thin' | 'thick';
        /**
          * Theme variant property.
         */
        "variant": 'light' | 'dark';
    }
    /**
     * Represents the main frame of the modal component.
     */
    interface InnoModal {
        /**
          * Should the modal be animated
         */
        "animation": boolean;
        /**
          * Show a backdrop behind the modal dialog
         */
        "backdrop": boolean;
        /**
          * Centered modal
         */
        "centered": boolean;
        /**
          * Close the dialog
         */
        "closeModal": <T = any>(reason: T) => Promise<void>;
        /**
          * Dismiss modal on backdrop click
         */
        "closeOnBackdropClick": boolean;
        /**
          * If set to true the modal can be closed by pressing the Escape key
         */
        "closeOnEscape": boolean;
        /**
          * Dismiss the dialog
         */
        "dismissModal": <T = any>(reason?: T) => Promise<void>;
        /**
          * By default the modal always opens at the top and the InnoModal component automatically scrolls to it. Set this to true if you want the modal to be always in a fixed position no matter where you scroll.
         */
        "fixed": boolean;
        /**
          * Show the dialog.
         */
        "showModal": () => Promise<void>;
        /**
          * Modal size
         */
        "size": InnoModalSize;
        /**
          * Theme variant of the component.
         */
        "variant": 'dark' | 'light';
    }
    /**
     * Represents the main content of the modal.
     * The content is provided by the user.
     * See the inno-modal component for more information.
     */
    interface InnoModalContent {
    }
    /**
     * Represents the footer content for the InnoModal component.
     * See the inno-modal component for more information.
     */
    interface InnoModalFooter {
    }
    /**
     * Represents the header of the inno-modal component.
     * See the inno-modal component for more information.
     */
    interface InnoModalHeader {
        /**
          * Icon of the header, optional.
         */
        "icon"?: string;
        /**
          * Hide the close button.
         */
        "showClose": boolean;
        /**
          * Theme variant of the component.
         */
        "variant": 'dark' | 'light';
    }
    interface InnoPaginator {
        /**
          * Total number of pages
         */
        "pageCount": number;
        /**
          * One based index of currently selected page
         */
        "selectedPage": number;
        "variant": 'dark' | 'light';
    }
    interface InnoPane {
        /**
          * Whether the pane is closeable by clicking outside of it.
         */
        "closeOnBackdropClick": boolean;
        /**
          * Programatically control whether the pane is opened or closed.
         */
        "expanded": boolean;
        /**
          * The pane comes with a close button by default. Hide it with this property.
         */
        "hideCloseButton": boolean;
        /**
          * Size of the pane. It is a width value in case of 'left' and 'right' position, and a height value in case of 'top' and 'bottom' position.  All css units are supported which are supported by width and height css properties.
         */
        "paneSize": string;
        /**
          * Position of the pane.
         */
        "position": 'top' | 'left' | 'bottom' | 'right';
        /**
          * Title of the pane.
         */
        "titleText": string;
    }
    interface InnoPopover {
        "animationFrame": boolean;
        /**
          * Popover will have a close button. Has no effect if trigger type is 'hover'.
         */
        "closable": boolean;
        /**
          * Css selector of the element the popover is for. This is just the initial value,  don't update it manually. Use the 'updateForElement(...)' method instead.
         */
        "for": string;
        /**
          * Popover should have a backdrop. Has no effect if trigger type is 'hover'.
         */
        "hasBackdrop": boolean;
        /**
          * Hide the tooltip.
         */
        "hideTooltip": () => Promise<void>;
        /**
          * Offset of the popover position in pixels. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "offset": number;
        /**
          * Position of the popover. If there is not enough space it will be automatically placed to where it has enough place. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "placement": Placement;
        /**
          * Contents of the text. Can be either html or a simple string. Can be omitted. You can use this property if you want a simple tooltip,  otherwise you can provide your own html directly.
         */
        "popoverText": string;
        /**
          * Contents of the title. Can be either html or a simple string. Can be omitted.
         */
        "popoverTitle": string;
        /**
          * Show the tooltip.
         */
        "showTooltip": () => Promise<void>;
        /**
          * How to show the popover. If set to 'manual' then you need to programatically modify the 'visibile' property.
         */
        "trigger": 'hover' | 'click' | 'manual';
        /**
          * Updates the element the popover is for including all the internal event listeners and the popover's position. If called without a parameter it will refresh the internal event listeners and the popover's position for the current target element. If called with a nonexisting selector it will refresh the internal event listeners and the popover's position for the current target element. Returns a Promise which is 'true' when the update/refresh succeded.  Returns 'false' if neither the current target element nor the element from the parameter exists.
         */
        "updateForElement": (forElement?: string) => Promise<boolean>;
        /**
          * Color variant of the popover.
         */
        "variant": 'light' | 'dark';
        /**
          * Programatically change whether the popover is visible or not.
         */
        "visible": boolean;
    }
    interface InnoProgressBar {
        /**
          * If the percentage number is shown, how many decimal places should be visible
         */
        "percentagePrecision": number;
        /**
          * Progress in percentage. Must be a number between 0 and 100.
         */
        "progressPercentage": number;
        /**
          * Text to display for the progress bar.
         */
        "progressText": string;
        /**
          * Show the percentage number on the progress bar. The value is rounded according to the 'percentagePrecision' and 'trailingZeroes' properties.
         */
        "showPercentage": boolean;
        /**
          * If 'percentagePrecision' is larger than 0, should we display the trailing zeroes. For example if the progress is 1.5% and the 'percentagePrecision' is 2 then the displayed text will be '1.50%'  if trailing zeroes are enabled and '1.5%' if trailing zeroes are disabled. Uses the toFixed(..) function in the background.
         */
        "trailingZeroes": boolean;
        /**
          * Color variant of the progress bar.
         */
        "variant": 'light' | 'dark';
    }
    /**
     * Represents the default radio button for the Innomics applications.
     */
    interface InnoRadio {
        "checked": boolean;
        /**
          * Whether component is disabled. In this state no other state effects are applied to the element like error.
         */
        "disabled": boolean;
        /**
          * Whether the element is in error state. Error state can be defined if manual error handling is required.
         */
        "error": boolean;
        /**
          * Label to show.
         */
        "label": string;
        /**
          * Form entry group name.
         */
        "name": string;
        /**
          * Whether the component is readonly. In this state no other state effects are applied to the element like error.
         */
        "readonly": boolean;
        /**
          * Mark the component as required and show the required marker. Validation is performed with this property.
         */
        "required": boolean;
        /**
          * The tab index.
         */
        "tabIdx": number;
        /**
          * Remove the selection from the given control. Can be used to synchronize the selection state between the radio group elements if manual control is required.
         */
        "unselect": () => Promise<void>;
        /**
          * Radio button value.
         */
        "value": string;
        /**
          * Theme variant of the component.
         */
        "variant": 'dark' | 'light';
    }
    interface InnoSelect {
        /**
          * The floating label is an absolutely positioned element meaning if it is too long it will grow out of the boundaries of the InnoSelect component. By default the InnoSelect component automatically resizes the floating label so it will fit inside. You can turn this behavior off e.g. if you are sure the label will always fit or it causes some issues.
         */
        "disableFloatingLabelAutoResize": boolean;
        /**
          * Whether the select is disabled or not.
         */
        "disabled": boolean;
        /**
          * By default the InnoSelect component automatically resizes the dropdown so it will be as wide as the component itself. You can override it to be a fixed width. Accepts any value that the 'width' css property accepts, e.g. "300px" or "min-content"
         */
        "dropdownWidth": string;
        /**
          * Icon for select when no item selected When icon is present the label is not behaves as floating
         */
        "icon": string;
        /**
          * If you work with object arrays you can set a simple function which returns the unique key value  so the objects can be differentiated. By default we assume you work with simple arrays so we simply return the value as it is, in that case you don't have to provide this function.
         */
        "keyValueSelector": (val: any) => any;
        /**
          * Label for the select when no item selected.
         */
        "label": string;
        /**
          * Can be used to force the inno-select component to rerender.
         */
        "refresh": () => Promise<void>;
        /**
          * Value of the select.
         */
        "value": any;
        /**
          * Color variant of the select.
         */
        "variant": 'light' | 'dark';
    }
    interface InnoSelectItem {
        /**
          * Tooltip text for favorite add. The tooltip is only visible if the InnoSelectItem has a unique id.
         */
        "addToFavoritesLabel": string;
        /**
          * Adds a favorite icon to the selectable item. If you press this icon an event will be fired with the selected item.  You have to take care of managing and ordering the array of favorite items in your business logic. Clicking on the favorite icon will not close the dropdown.
         */
        "canFavorite": boolean;
        /**
          * Offset of the favorite icon tooltip position in pixels. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "favoriteIconTooltipOffset": number;
        /**
          * Position of the favorite icon tooltip. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "favoriteIconTooltipPos": Placement;
        /**
          * Color variant of the favorite icon tooltip.
         */
        "favoriteIconTooltipVariant": 'light' | 'dark';
        /**
          * A simple separator for the item. You can use it for example to visually separate the favorited and non-favorited items.
         */
        "hasSeparator": boolean;
        /**
          * Optional icon for the label.
         */
        "icon": string;
        /**
          * The selectable item is favorited or not.
         */
        "isFavorite": boolean;
        /**
          * Label of the item, can be different from the value.
         */
        "label": string;
        /**
          * Tooltip text for favorite remove. The tooltip is only visible if the InnoSelectItem has a unique id.
         */
        "removeFromFavoritesLabel": string;
        /**
          * Whether the item is selected or not.
         */
        "selected": boolean;
        /**
          * Value of the item.
         */
        "value": any;
    }
    /**
     * Represents a status message entry.
     */
    interface InnoStatusMessage {
        /**
          * Autoclose message after the given delay. The message will be closed independently from showProgress property.
         */
        "autoClose": boolean;
        /**
          * Autoclose delay.
         */
        "autoCloseDelay": number;
        /**
          * Icon of toast
         */
        "icon": string;
        /**
          * Icon color of toast
         */
        "iconColor": string;
        /**
          * Type of the status message.
         */
        "messageType": InnoStatusMessageType;
        /**
          * Animate progressbar and close after animation ends. The message will be closed independently from autoClose property.
         */
        "showProgress": boolean;
        /**
          * Theme variant of the component.
         */
        "theme": InnoStatusMessageTheme;
    }
    /**
     * Container to hold the status messages.
     */
    interface InnoStatusMessageContainer {
        /**
          * Customizable container class.
         */
        "containerClass": string;
        /**
          * Customizable container id.
         */
        "containerId": string;
        /**
          * Position of container.
         */
        "position": InnoStatusMessagePosition;
        /**
          * Display a toast message
          * @param config
         */
        "showStatusMessage": (config: InnoStatusMessageConfig) => Promise<ShowStatusMessageResult>;
    }
    interface InnoTab {
        /**
          * Make the non-selected items always vivid without any opacity effect.
         */
        "alwaysEmphasized": boolean;
        /**
          * Programatically change the selected tab by its index and scroll to the selected inno-tab-item inside the inno-tab. Please note that manually changing the 'selected' property won't do any scrolling, that is only possible with this method.
         */
        "changeSelected": (newIndex: number) => Promise<void>;
        /**
          * Set layout width style
         */
        "layout": 'auto' | 'stretched';
        /**
          * Minimalize the bottom decorator for the tab items. Show only if the given item is interracted or selected.
         */
        "minimalDecorator": boolean;
        /**
          * Set default selected tab by index or undefined if not tab is selected.
         */
        "selected": number | undefined;
        /**
          * Show the navigation arrow for desktop.
         */
        "showArrow": boolean;
        /**
          * Theme variant of the component.
         */
        "theme": 'light' | 'dark';
    }
    /**
     * Represents an inno-tab item.
     * Wraps the provided content.
     * See the InnoTab component for more information about how to use the tab component.
     */
    interface InnoTabItem {
        /**
          * Make the non-selected items always vivid without any opacity effect.
         */
        "alwaysEmphasized": boolean;
        /**
          * Set disabled tab.
         */
        "disabled": boolean;
        /**
          * Set layout width style. Auto: Item has the same width as the enclosed item in slot. Stretched: Item has the maximum available width.
         */
        "layout": 'auto' | 'stretched';
        /**
          * Minimalize the bottom decorator for the tab items. Show only if the given item is interracted or selected.
         */
        "minimalDecorator": boolean;
        /**
          * Set selected tab.
         */
        "selected": boolean;
        /**
          * Theme variant property. Inherited from the parent. Can be overridden if explicitly defined.
         */
        "theme": 'light' | 'dark';
    }
    /**
     * Basic wrapper element for html tables. Adds some basic styling to the table and a custom scrollbar with fade-out effect.
     * Can be used without html table as well, in that case only the custom scrollbar with fade-out effect will be applied to the html element.
     */
    interface InnoTableBase {
        /**
          * The fade-out effect while scrolling is achieved by using mask-image and linear-gradient.  For it to work properly a color must be set to be the same as the table's background color.
         */
        "maskColor": string;
        /**
          * The component tries its best to always apply the custom scrollbar and the fade-out effect automatically but there might be some cases  (especially during/after initalization) where it just simply won't work. In those cases you can call this method manually.
         */
        "refresh": () => Promise<void>;
        /**
          * Color variant of the table;
         */
        "variant": 'light' | 'dark';
    }
    interface InnoTimePicker {
        /**
          * Date format string. See "https://moment.github.io/luxon/#/formatting?id=table-of-tokens" for all available tokens.
         */
        "format": string;
        /**
          * Component text configuration.
         */
        "texts"?: InnoTimePickerTexts | undefined;
        /**
          * Theme variant of the component.
         */
        "theme": 'light' | 'dark';
        "time": string | undefined;
    }
    interface InnoToggle {
        /**
          * Whether the slide-toggle element is checked or not. Can be changed programatically, will emit a change event.
         */
        "checked": boolean;
        /**
          * Whether the slide-toggle element is disabled or not.
         */
        "disabled": boolean;
        /**
          * The tab index of the toggle
         */
        "tabIdx": number;
        /**
          * Color variant of the toggle component.
         */
        "variant": 'dark' | 'light';
    }
}
export interface InnoAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoAccordionElement;
}
export interface InnoBreadcrumbCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoBreadcrumbElement;
}
export interface InnoBreadcrumbItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoBreadcrumbItemElement;
}
export interface InnoCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoCheckboxElement;
}
export interface InnoDatePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoDatePickerElement;
}
export interface InnoDatePickerDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoDatePickerDropdownElement;
}
export interface InnoDragAndDropCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoDragAndDropElement;
}
export interface InnoInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoInputElement;
}
export interface InnoModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoModalElement;
}
export interface InnoModalHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoModalHeaderElement;
}
export interface InnoPaginatorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoPaginatorElement;
}
export interface InnoPaneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoPaneElement;
}
export interface InnoPopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoPopoverElement;
}
export interface InnoRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoRadioElement;
}
export interface InnoSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoSelectElement;
}
export interface InnoSelectItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoSelectItemElement;
}
export interface InnoStatusMessageCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoStatusMessageElement;
}
export interface InnoTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoTabElement;
}
export interface InnoTabItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoTabItemElement;
}
export interface InnoTimePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoTimePickerElement;
}
export interface InnoToggleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInnoToggleElement;
}
declare global {
    interface HTMLInnoAccordionElementEventMap {
        "collapsedChanged": { element: HTMLInnoAccordionElement, collapsed: boolean };
    }
    interface HTMLInnoAccordionElement extends Components.InnoAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoAccordionElementEventMap>(type: K, listener: (this: HTMLInnoAccordionElement, ev: InnoAccordionCustomEvent<HTMLInnoAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoAccordionElementEventMap>(type: K, listener: (this: HTMLInnoAccordionElement, ev: InnoAccordionCustomEvent<HTMLInnoAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoAccordionElement: {
        prototype: HTMLInnoAccordionElement;
        new (): HTMLInnoAccordionElement;
    };
    interface HTMLInnoBreadcrumbElementEventMap {
        "itemClick": {itemIndex: number, label: string};
    }
    interface HTMLInnoBreadcrumbElement extends Components.InnoBreadcrumb, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoBreadcrumbElementEventMap>(type: K, listener: (this: HTMLInnoBreadcrumbElement, ev: InnoBreadcrumbCustomEvent<HTMLInnoBreadcrumbElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoBreadcrumbElementEventMap>(type: K, listener: (this: HTMLInnoBreadcrumbElement, ev: InnoBreadcrumbCustomEvent<HTMLInnoBreadcrumbElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoBreadcrumbElement: {
        prototype: HTMLInnoBreadcrumbElement;
        new (): HTMLInnoBreadcrumbElement;
    };
    interface HTMLInnoBreadcrumbItemElementEventMap {
        "breadcrumbItemClick": { itemIndex: number, label: string };
    }
    interface HTMLInnoBreadcrumbItemElement extends Components.InnoBreadcrumbItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoBreadcrumbItemElementEventMap>(type: K, listener: (this: HTMLInnoBreadcrumbItemElement, ev: InnoBreadcrumbItemCustomEvent<HTMLInnoBreadcrumbItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoBreadcrumbItemElementEventMap>(type: K, listener: (this: HTMLInnoBreadcrumbItemElement, ev: InnoBreadcrumbItemCustomEvent<HTMLInnoBreadcrumbItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoBreadcrumbItemElement: {
        prototype: HTMLInnoBreadcrumbItemElement;
        new (): HTMLInnoBreadcrumbItemElement;
    };
    interface HTMLInnoButtonElement extends Components.InnoButton, HTMLStencilElement {
    }
    var HTMLInnoButtonElement: {
        prototype: HTMLInnoButtonElement;
        new (): HTMLInnoButtonElement;
    };
    interface HTMLInnoCheckboxElementEventMap {
        "valueChange": boolean;
    }
    /**
     * Checkbox for Innomatics design system.
     */
    interface HTMLInnoCheckboxElement extends Components.InnoCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoCheckboxElementEventMap>(type: K, listener: (this: HTMLInnoCheckboxElement, ev: InnoCheckboxCustomEvent<HTMLInnoCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoCheckboxElementEventMap>(type: K, listener: (this: HTMLInnoCheckboxElement, ev: InnoCheckboxCustomEvent<HTMLInnoCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoCheckboxElement: {
        prototype: HTMLInnoCheckboxElement;
        new (): HTMLInnoCheckboxElement;
    };
    interface HTMLInnoDatePickerElementEventMap {
        "dateChange": DateChange;
    }
    /**
     * Innomotics date-picker.
     */
    interface HTMLInnoDatePickerElement extends Components.InnoDatePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoDatePickerElementEventMap>(type: K, listener: (this: HTMLInnoDatePickerElement, ev: InnoDatePickerCustomEvent<HTMLInnoDatePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoDatePickerElementEventMap>(type: K, listener: (this: HTMLInnoDatePickerElement, ev: InnoDatePickerCustomEvent<HTMLInnoDatePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoDatePickerElement: {
        prototype: HTMLInnoDatePickerElement;
        new (): HTMLInnoDatePickerElement;
    };
    interface HTMLInnoDatePickerDropdownElementEventMap {
        "dateChange": DateChange;
    }
    /**
     * Date-picker with dropdown.
     */
    interface HTMLInnoDatePickerDropdownElement extends Components.InnoDatePickerDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoDatePickerDropdownElementEventMap>(type: K, listener: (this: HTMLInnoDatePickerDropdownElement, ev: InnoDatePickerDropdownCustomEvent<HTMLInnoDatePickerDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoDatePickerDropdownElementEventMap>(type: K, listener: (this: HTMLInnoDatePickerDropdownElement, ev: InnoDatePickerDropdownCustomEvent<HTMLInnoDatePickerDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoDatePickerDropdownElement: {
        prototype: HTMLInnoDatePickerDropdownElement;
        new (): HTMLInnoDatePickerDropdownElement;
    };
    interface HTMLInnoDateTimeCardElement extends Components.InnoDateTimeCard, HTMLStencilElement {
    }
    var HTMLInnoDateTimeCardElement: {
        prototype: HTMLInnoDateTimeCardElement;
        new (): HTMLInnoDateTimeCardElement;
    };
    interface HTMLInnoDragAndDropElementEventMap {
        "filesChanged": Array<File>;
    }
    interface HTMLInnoDragAndDropElement extends Components.InnoDragAndDrop, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoDragAndDropElementEventMap>(type: K, listener: (this: HTMLInnoDragAndDropElement, ev: InnoDragAndDropCustomEvent<HTMLInnoDragAndDropElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoDragAndDropElementEventMap>(type: K, listener: (this: HTMLInnoDragAndDropElement, ev: InnoDragAndDropCustomEvent<HTMLInnoDragAndDropElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoDragAndDropElement: {
        prototype: HTMLInnoDragAndDropElement;
        new (): HTMLInnoDragAndDropElement;
    };
    interface HTMLInnoErrorElement extends Components.InnoError, HTMLStencilElement {
    }
    var HTMLInnoErrorElement: {
        prototype: HTMLInnoErrorElement;
        new (): HTMLInnoErrorElement;
    };
    /**
     * Represents the general footer for the Innomotics applications.
     */
    interface HTMLInnoFooterElement extends Components.InnoFooter, HTMLStencilElement {
    }
    var HTMLInnoFooterElement: {
        prototype: HTMLInnoFooterElement;
        new (): HTMLInnoFooterElement;
    };
    /**
     * Represents an inno-footer item.
     * Wrap an element for the inno-footer parent.
     * See the InnoFooter docs for more information.
     */
    interface HTMLInnoFooterItemElement extends Components.InnoFooterItem, HTMLStencilElement {
    }
    var HTMLInnoFooterItemElement: {
        prototype: HTMLInnoFooterItemElement;
        new (): HTMLInnoFooterItemElement;
    };
    interface HTMLInnoIconElement extends Components.InnoIcon, HTMLStencilElement {
    }
    var HTMLInnoIconElement: {
        prototype: HTMLInnoIconElement;
        new (): HTMLInnoIconElement;
    };
    interface HTMLInnoInputElementEventMap {
        "valueChanged": string | number;
    }
    interface HTMLInnoInputElement extends Components.InnoInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoInputElementEventMap>(type: K, listener: (this: HTMLInnoInputElement, ev: InnoInputCustomEvent<HTMLInnoInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoInputElementEventMap>(type: K, listener: (this: HTMLInnoInputElement, ev: InnoInputCustomEvent<HTMLInnoInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoInputElement: {
        prototype: HTMLInnoInputElement;
        new (): HTMLInnoInputElement;
    };
    interface HTMLInnoLoaderElement extends Components.InnoLoader, HTMLStencilElement {
    }
    var HTMLInnoLoaderElement: {
        prototype: HTMLInnoLoaderElement;
        new (): HTMLInnoLoaderElement;
    };
    interface HTMLInnoModalElementEventMap {
        "dialogClose": any;
        "dialogDismiss": any;
    }
    /**
     * Represents the main frame of the modal component.
     */
    interface HTMLInnoModalElement extends Components.InnoModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoModalElementEventMap>(type: K, listener: (this: HTMLInnoModalElement, ev: InnoModalCustomEvent<HTMLInnoModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoModalElementEventMap>(type: K, listener: (this: HTMLInnoModalElement, ev: InnoModalCustomEvent<HTMLInnoModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoModalElement: {
        prototype: HTMLInnoModalElement;
        new (): HTMLInnoModalElement;
    };
    /**
     * Represents the main content of the modal.
     * The content is provided by the user.
     * See the inno-modal component for more information.
     */
    interface HTMLInnoModalContentElement extends Components.InnoModalContent, HTMLStencilElement {
    }
    var HTMLInnoModalContentElement: {
        prototype: HTMLInnoModalContentElement;
        new (): HTMLInnoModalContentElement;
    };
    /**
     * Represents the footer content for the InnoModal component.
     * See the inno-modal component for more information.
     */
    interface HTMLInnoModalFooterElement extends Components.InnoModalFooter, HTMLStencilElement {
    }
    var HTMLInnoModalFooterElement: {
        prototype: HTMLInnoModalFooterElement;
        new (): HTMLInnoModalFooterElement;
    };
    interface HTMLInnoModalHeaderElementEventMap {
        "closeClick": Event;
    }
    /**
     * Represents the header of the inno-modal component.
     * See the inno-modal component for more information.
     */
    interface HTMLInnoModalHeaderElement extends Components.InnoModalHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoModalHeaderElementEventMap>(type: K, listener: (this: HTMLInnoModalHeaderElement, ev: InnoModalHeaderCustomEvent<HTMLInnoModalHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoModalHeaderElementEventMap>(type: K, listener: (this: HTMLInnoModalHeaderElement, ev: InnoModalHeaderCustomEvent<HTMLInnoModalHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoModalHeaderElement: {
        prototype: HTMLInnoModalHeaderElement;
        new (): HTMLInnoModalHeaderElement;
    };
    interface HTMLInnoPaginatorElementEventMap {
        "pageSelected": number;
        "itemCountChanged": number;
    }
    interface HTMLInnoPaginatorElement extends Components.InnoPaginator, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoPaginatorElementEventMap>(type: K, listener: (this: HTMLInnoPaginatorElement, ev: InnoPaginatorCustomEvent<HTMLInnoPaginatorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoPaginatorElementEventMap>(type: K, listener: (this: HTMLInnoPaginatorElement, ev: InnoPaginatorCustomEvent<HTMLInnoPaginatorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoPaginatorElement: {
        prototype: HTMLInnoPaginatorElement;
        new (): HTMLInnoPaginatorElement;
    };
    interface HTMLInnoPaneElementEventMap {
        "expandedChanged": ExpandedChangedEvent;
    }
    interface HTMLInnoPaneElement extends Components.InnoPane, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoPaneElementEventMap>(type: K, listener: (this: HTMLInnoPaneElement, ev: InnoPaneCustomEvent<HTMLInnoPaneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoPaneElementEventMap>(type: K, listener: (this: HTMLInnoPaneElement, ev: InnoPaneCustomEvent<HTMLInnoPaneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoPaneElement: {
        prototype: HTMLInnoPaneElement;
        new (): HTMLInnoPaneElement;
    };
    interface HTMLInnoPopoverElementEventMap {
        "innoPopoverShown": void;
        "innoPopoverHidden": void;
    }
    interface HTMLInnoPopoverElement extends Components.InnoPopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoPopoverElementEventMap>(type: K, listener: (this: HTMLInnoPopoverElement, ev: InnoPopoverCustomEvent<HTMLInnoPopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoPopoverElementEventMap>(type: K, listener: (this: HTMLInnoPopoverElement, ev: InnoPopoverCustomEvent<HTMLInnoPopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoPopoverElement: {
        prototype: HTMLInnoPopoverElement;
        new (): HTMLInnoPopoverElement;
    };
    interface HTMLInnoProgressBarElement extends Components.InnoProgressBar, HTMLStencilElement {
    }
    var HTMLInnoProgressBarElement: {
        prototype: HTMLInnoProgressBarElement;
        new (): HTMLInnoProgressBarElement;
    };
    interface HTMLInnoRadioElementEventMap {
        "valueChange": string;
    }
    /**
     * Represents the default radio button for the Innomics applications.
     */
    interface HTMLInnoRadioElement extends Components.InnoRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoRadioElementEventMap>(type: K, listener: (this: HTMLInnoRadioElement, ev: InnoRadioCustomEvent<HTMLInnoRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoRadioElementEventMap>(type: K, listener: (this: HTMLInnoRadioElement, ev: InnoRadioCustomEvent<HTMLInnoRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoRadioElement: {
        prototype: HTMLInnoRadioElement;
        new (): HTMLInnoRadioElement;
    };
    interface HTMLInnoSelectElementEventMap {
        "valueChanged": string;
        "itemIsFavorited": any;
        "itemIsUnfavorited": any;
        "favoriteItemsChanged": any;
        "dropdownClosed": void;
    }
    interface HTMLInnoSelectElement extends Components.InnoSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoSelectElementEventMap>(type: K, listener: (this: HTMLInnoSelectElement, ev: InnoSelectCustomEvent<HTMLInnoSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoSelectElementEventMap>(type: K, listener: (this: HTMLInnoSelectElement, ev: InnoSelectCustomEvent<HTMLInnoSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoSelectElement: {
        prototype: HTMLInnoSelectElement;
        new (): HTMLInnoSelectElement;
    };
    interface HTMLInnoSelectItemElementEventMap {
        "itemSelected": any;
        "itemFavorited": any;
        "itemUnfavorited": any;
        "itemLabelChanged": any;
    }
    interface HTMLInnoSelectItemElement extends Components.InnoSelectItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoSelectItemElementEventMap>(type: K, listener: (this: HTMLInnoSelectItemElement, ev: InnoSelectItemCustomEvent<HTMLInnoSelectItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoSelectItemElementEventMap>(type: K, listener: (this: HTMLInnoSelectItemElement, ev: InnoSelectItemCustomEvent<HTMLInnoSelectItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoSelectItemElement: {
        prototype: HTMLInnoSelectItemElement;
        new (): HTMLInnoSelectItemElement;
    };
    interface HTMLInnoStatusMessageElementEventMap {
        "closeMessage": any;
    }
    /**
     * Represents a status message entry.
     */
    interface HTMLInnoStatusMessageElement extends Components.InnoStatusMessage, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoStatusMessageElementEventMap>(type: K, listener: (this: HTMLInnoStatusMessageElement, ev: InnoStatusMessageCustomEvent<HTMLInnoStatusMessageElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoStatusMessageElementEventMap>(type: K, listener: (this: HTMLInnoStatusMessageElement, ev: InnoStatusMessageCustomEvent<HTMLInnoStatusMessageElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoStatusMessageElement: {
        prototype: HTMLInnoStatusMessageElement;
        new (): HTMLInnoStatusMessageElement;
    };
    /**
     * Container to hold the status messages.
     */
    interface HTMLInnoStatusMessageContainerElement extends Components.InnoStatusMessageContainer, HTMLStencilElement {
    }
    var HTMLInnoStatusMessageContainerElement: {
        prototype: HTMLInnoStatusMessageContainerElement;
        new (): HTMLInnoStatusMessageContainerElement;
    };
    interface HTMLInnoTabElementEventMap {
        "selectedChange": number;
    }
    interface HTMLInnoTabElement extends Components.InnoTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoTabElementEventMap>(type: K, listener: (this: HTMLInnoTabElement, ev: InnoTabCustomEvent<HTMLInnoTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoTabElementEventMap>(type: K, listener: (this: HTMLInnoTabElement, ev: InnoTabCustomEvent<HTMLInnoTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoTabElement: {
        prototype: HTMLInnoTabElement;
        new (): HTMLInnoTabElement;
    };
    interface HTMLInnoTabItemElementEventMap {
        "tabClick": TabClickDetail;
    }
    /**
     * Represents an inno-tab item.
     * Wraps the provided content.
     * See the InnoTab component for more information about how to use the tab component.
     */
    interface HTMLInnoTabItemElement extends Components.InnoTabItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoTabItemElementEventMap>(type: K, listener: (this: HTMLInnoTabItemElement, ev: InnoTabItemCustomEvent<HTMLInnoTabItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoTabItemElementEventMap>(type: K, listener: (this: HTMLInnoTabItemElement, ev: InnoTabItemCustomEvent<HTMLInnoTabItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoTabItemElement: {
        prototype: HTMLInnoTabItemElement;
        new (): HTMLInnoTabItemElement;
    };
    /**
     * Basic wrapper element for html tables. Adds some basic styling to the table and a custom scrollbar with fade-out effect.
     * Can be used without html table as well, in that case only the custom scrollbar with fade-out effect will be applied to the html element.
     */
    interface HTMLInnoTableBaseElement extends Components.InnoTableBase, HTMLStencilElement {
    }
    var HTMLInnoTableBaseElement: {
        prototype: HTMLInnoTableBaseElement;
        new (): HTMLInnoTableBaseElement;
    };
    interface HTMLInnoTimePickerElementEventMap {
        "valueChange": any;
    }
    interface HTMLInnoTimePickerElement extends Components.InnoTimePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoTimePickerElementEventMap>(type: K, listener: (this: HTMLInnoTimePickerElement, ev: InnoTimePickerCustomEvent<HTMLInnoTimePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoTimePickerElementEventMap>(type: K, listener: (this: HTMLInnoTimePickerElement, ev: InnoTimePickerCustomEvent<HTMLInnoTimePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoTimePickerElement: {
        prototype: HTMLInnoTimePickerElement;
        new (): HTMLInnoTimePickerElement;
    };
    interface HTMLInnoToggleElementEventMap {
        "checkedChange": boolean;
    }
    interface HTMLInnoToggleElement extends Components.InnoToggle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInnoToggleElementEventMap>(type: K, listener: (this: HTMLInnoToggleElement, ev: InnoToggleCustomEvent<HTMLInnoToggleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInnoToggleElementEventMap>(type: K, listener: (this: HTMLInnoToggleElement, ev: InnoToggleCustomEvent<HTMLInnoToggleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInnoToggleElement: {
        prototype: HTMLInnoToggleElement;
        new (): HTMLInnoToggleElement;
    };
    interface HTMLElementTagNameMap {
        "inno-accordion": HTMLInnoAccordionElement;
        "inno-breadcrumb": HTMLInnoBreadcrumbElement;
        "inno-breadcrumb-item": HTMLInnoBreadcrumbItemElement;
        "inno-button": HTMLInnoButtonElement;
        "inno-checkbox": HTMLInnoCheckboxElement;
        "inno-date-picker": HTMLInnoDatePickerElement;
        "inno-date-picker-dropdown": HTMLInnoDatePickerDropdownElement;
        "inno-date-time-card": HTMLInnoDateTimeCardElement;
        "inno-drag-and-drop": HTMLInnoDragAndDropElement;
        "inno-error": HTMLInnoErrorElement;
        "inno-footer": HTMLInnoFooterElement;
        "inno-footer-item": HTMLInnoFooterItemElement;
        "inno-icon": HTMLInnoIconElement;
        "inno-input": HTMLInnoInputElement;
        "inno-loader": HTMLInnoLoaderElement;
        "inno-modal": HTMLInnoModalElement;
        "inno-modal-content": HTMLInnoModalContentElement;
        "inno-modal-footer": HTMLInnoModalFooterElement;
        "inno-modal-header": HTMLInnoModalHeaderElement;
        "inno-paginator": HTMLInnoPaginatorElement;
        "inno-pane": HTMLInnoPaneElement;
        "inno-popover": HTMLInnoPopoverElement;
        "inno-progress-bar": HTMLInnoProgressBarElement;
        "inno-radio": HTMLInnoRadioElement;
        "inno-select": HTMLInnoSelectElement;
        "inno-select-item": HTMLInnoSelectItemElement;
        "inno-status-message": HTMLInnoStatusMessageElement;
        "inno-status-message-container": HTMLInnoStatusMessageContainerElement;
        "inno-tab": HTMLInnoTabElement;
        "inno-tab-item": HTMLInnoTabItemElement;
        "inno-table-base": HTMLInnoTableBaseElement;
        "inno-time-picker": HTMLInnoTimePickerElement;
        "inno-toggle": HTMLInnoToggleElement;
    }
}
declare namespace LocalJSX {
    interface InnoAccordion {
        /**
          * You can programatically open/close the accordion with this property.
         */
        "collapsed"?: boolean;
        /**
          * Whether it is an accordion inside another accordion. Gives a different style then the main one.
         */
        "inner"?: boolean;
        /**
          * Text to display for the accordion. Always visible whether the accordion is opened or closed.
         */
        "label"?: string;
        /**
          * Whether the accordion is the last in a group of accordions. Needed for styling.
         */
        "last"?: boolean;
        /**
          * This event is fired whenever the accordion is opened/closed via user interaction.
         */
        "onCollapsedChanged"?: (event: InnoAccordionCustomEvent<{ element: HTMLInnoAccordionElement, collapsed: boolean }>) => void;
        /**
          * Secondary text for the accordion. Always visible whether the accordion is opened or closed.
         */
        "secondLabel"?: string;
        /**
          * Color variant of the accordion.
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoBreadcrumb {
        /**
          * Crumb item clicked event. The event contains the label and the zero-based index of the breadcrumb item inside the breadcrumb.
         */
        "onItemClick"?: (event: InnoBreadcrumbCustomEvent<{itemIndex: number, label: string}>) => void;
        /**
          * Color variant of the accordion.
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoBreadcrumbItem {
        /**
          * Icon to be displayed next ot the label
         */
        "icon"?: string;
        "iconSize"?: number;
        "itemIndex"?: number;
        /**
          * Breadcrumb label
         */
        "label"?: string;
        "onBreadcrumbItemClick"?: (event: InnoBreadcrumbItemCustomEvent<{ itemIndex: number, label: string }>) => void;
        "showChevron"?: boolean;
        "visible"?: boolean;
    }
    interface InnoButton {
        /**
          * Color variant of the button.
         */
        "colorVariant"?: 'light' | 'dark';
        /**
          * Whether the button is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * Icon to use inside the button.
         */
        "icon"?: string;
        /**
          * Only show an icon.
         */
        "iconOnly"?: boolean;
        /**
          * Where to put the icon relative to the text.
         */
        "iconPosition"?: 'left' | 'right';
        /**
          * Special style for button lists.
         */
        "listType"?: boolean;
        /**
          * Direction of the navigation button. Only has effect if the variant is 'navigation'.
         */
        "navDirection"?: 'left' | 'right';
        /**
          * Tab index of the button.
         */
        "tabIdx"?: number;
        /**
          * Type of the button.
         */
        "type"?: 'button' | 'submit';
        /**
          * Variant of the button.
         */
        "variant"?: 'primary' | 'secondary' | 'tertiary' | 'media' | 'navigation' | 'delete';
    }
    /**
     * Checkbox for Innomatics design system.
     */
    interface InnoCheckbox {
        /**
          * Whether element is checked.
         */
        "checked"?: boolean | undefined;
        /**
          * Whether component is disabled. In this state no other state effects are applied to the element like error.
         */
        "disabled"?: boolean;
        /**
          * Whether the element is in error state. Error state can be defined if manual error handling is required.
         */
        "error"?: boolean;
        /**
          * Whether indeterminate state is enabled for the component. The component is in indeterminate state if it is explicity requested and the checked status is not defined
         */
        "indeterminate"?: boolean;
        /**
          * Label to show.
         */
        "label"?: string;
        /**
          * Form entry name.
         */
        "name"?: string;
        /**
          * Checked status has been changed.
         */
        "onValueChange"?: (event: InnoCheckboxCustomEvent<boolean>) => void;
        /**
          * Whether the component is readonly. In this state no other state effects are applied to the element like error.
         */
        "readonly"?: boolean;
        /**
          * Mark the component as required and show the required marker. Validation is performed with this property.
         */
        "required"?: boolean;
        /**
          * The tab index.
         */
        "tabIdx"?: number;
        /**
          * Theme variant of the component.
         */
        "variant"?: 'dark' | 'light';
    }
    /**
     * Innomotics date-picker.
     */
    interface InnoDatePicker {
        /**
          * Date format string. See "https://moment.github.io/luxon/#/formatting?id=table-of-tokens" for all available tokens.
         */
        "format"?: string;
        /**
          * The selected starting date. If the date-picker is not in range mode this is the selected date. Format has to match the `format` property.
         */
        "from"?: string | undefined;
        /**
          * Text of date select button
         */
        "i18nDone"?: string;
        /**
          * Format of time string See "https://moment.github.io/luxon/#/formatting?id=table-of-tokens" for all available tokens.
         */
        "locale"?: string;
        /**
          * The latest date that can be selected by the date picker. If not set there will be no restriction.
         */
        "maxDate"?: string;
        /**
          * The earliest date that can be selected by the date picker. If not set there will be no restriction.
         */
        "minDate"?: string;
        /**
          * Triggers if the date selection changes.
         */
        "onDateChange"?: (event: InnoDatePickerCustomEvent<DateChange>) => void;
        /**
          * If true a date-range can be selected (from/to).
         */
        "range"?: boolean;
        /**
          * Show the days outside the selected month.
         */
        "showOuterDays"?: boolean;
        "standaloneAppearance"?: boolean;
        /**
          * The selected end date. If the date-picker is not in range mode this property has no impact. Format has to match the `format` property.
         */
        "to"?: string | undefined;
        "today"?: string;
        /**
          * The index of which day to start the week on, based on the Locale#weekdays array. E.g. if the locale is en-us, weekStartIndex = 1 results in starting the week on monday.
         */
        "weekStartIndex"?: number;
    }
    /**
     * Date-picker with dropdown.
     */
    interface InnoDatePickerDropdown {
        "closeOnSelection"?: boolean;
        /**
          * Date format string. See the date-picker component for more information.
         */
        "format"?: string;
        /**
          * The selected starting range. See the date-picker component for more information.
         */
        "from"?: string | undefined;
        /**
          * Label of the dropdown component.
         */
        "label"?: string | undefined;
        /**
          * Format of the date strings. See the date-picker component for more information.
         */
        "locale"?: string;
        /**
          * The latest date that can be selected by the date picker. See the date-picker component for more information.
         */
        "maxDate"?: string;
        /**
          * The earliest date that can be selected by the date picker. See the date-picker component for more information.
         */
        "minDate"?: string;
        /**
          * Triggers if the date selection changes. See the date-picker component for more information.
         */
        "onDateChange"?: (event: InnoDatePickerDropdownCustomEvent<DateChange>) => void;
        /**
          * If true a date-range can be selected. See the date-picker component for more information.
         */
        "range"?: boolean;
        /**
          * Show the days outside the selected month. See the date-picker component for more information.
         */
        "showOuterDays"?: boolean;
        /**
          * The selected end date. See the date-picker component for more information.
         */
        "to"?: string | undefined;
        /**
          * Color variant of the component.
         */
        "variant"?: 'dark' | 'light';
        /**
          * The index of which day to start the week on. See the date-picker component for more information.
         */
        "weekStartIndex"?: number;
    }
    interface InnoDateTimeCard {
        "standaloneAppearance"?: boolean;
    }
    interface InnoDragAndDrop {
        /**
          * The accept attribute specifies the types of files that the server accepts (that can be submitted through a file upload). "https://www.w3schools.com/tags/att_input_accept.asp"
         */
        "accept"?: string;
        /**
          * Disable all input events
         */
        "disabled"?: boolean;
        /**
          * If multiple is true the user can drop or select multiple files
         */
        "multiple"?: boolean;
        "onFilesChanged"?: (event: InnoDragAndDropCustomEvent<Array<File>>) => void;
        /**
          * After a file is uploaded you can set the upload component to a defined state
         */
        "state"?: 'SELECT_FILE' | 'LOADING' | 'UPLOAD_FAILED' | 'UPLOAD_SUCCESS';
        /**
          * 'firstLineText' and 'secondLineText': will be used by state = 'SELECT_FILE', <br/><br/>'orText': The word 'or' or its equivalent translation. Hidden if only 'firstLineText' or only 'secondLineText' is used, <br/><br/>'dragText': displayed when file is dragged over the component, can be omitted, <br/><br/>'loadingText': will be used by state = 'LOADING', <br/><br/>'uploadFailedText': will be used by state = 'UPLOAD_FAILED', <br/><br/>'uploadSuccessText': will be used by state = 'UPLOAD_SUCCESS', <br/><br/>'acceptedFileTypesText': label for accepted file types, <br/><br/>'uploadDisabledText': label for disabled state
         */
        "texts"?: DragAndDropTexts;
        /**
          * Color variant of the component.
         */
        "variant"?: 'dark' | 'light';
    }
    interface InnoError {
        /**
          * Show the error or not.
         */
        "active"?: boolean;
        /**
          * The input's validation error type, see: https://developer.mozilla.org/en-US/docs/Web/API/ValidityState
         */
        "type"?: 'badInput' | 'customError' | 'patternMismatch' | 'rangeOverflow' | 'rangeUnderflow' | 'stepMismatch' | 'tooLong' | 'tooShort' | 'typeMismatch' | 'valid' | 'valueMissing' | undefined;
        /**
          * Theme variant of the input.
         */
        "variant"?: 'dark' | 'light';
    }
    /**
     * Represents the general footer for the Innomotics applications.
     */
    interface InnoFooter {
        /**
          * The copyright label.
         */
        "copyright"?: string;
        /**
          * Theme variant property.
         */
        "variant"?: 'light' | 'dark';
    }
    /**
     * Represents an inno-footer item.
     * Wrap an element for the inno-footer parent.
     * See the InnoFooter docs for more information.
     */
    interface InnoFooterItem {
        /**
          * Theme variant property. Inherited from the parent. Can be overridden if explicitly defined.
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoIcon {
        /**
          * The icon name. Use this or the iconFont property.
         */
        "icon"?: string;
        /**
          * Font icon code for the InnomoticsUiIcons font. Use this or the icon property.
         */
        "iconFont"?: string;
        "size"?: number;
        /**
          * Color style of the icon.
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoInput {
        /**
          * When you click on the inno-input a focus() command is called on the input element. This might cause that the caret position will be at the beginnging of the input's value. Set this to true if you want the caret position to be at the end. Only has an effect if the input type is 'text'. Has no effect if 'selectOnFocus' is also true.
         */
        "caretPosEndOnFocus"?: boolean;
        /**
          * The floating label is an absolutely positioned element meaning if it is too long it will grow out of the boundaries of the InnoInput component. By default the InnoInput component automatically resizes the floating label so it will fit inside. You can turn this behavior off e.g. if you are sure the label will always fit or it causes some issues.
         */
        "disableFloatingLabelAutoResize"?: boolean;
        /**
          * Whether the inno-input component is disabled or not. Probably not needed to be set since the component automatically detects if the inserted input element is disabled or not. The inno-input component will also be in a disabled state when the input element is readonly.
         */
        "disabled"?: boolean;
        /**
          * Error message to show. If you don't want to use this property you can manually add 'inno-error' components inside the 'inno-input' component. You can either use this property or use the manually added errors. Can't use both at the same time.
         */
        "error"?: string;
        /**
          * The input's validation error type, see: https://developer.mozilla.org/en-US/docs/Web/API/ValidityState <br/><br/>Only has an effect if 'error' has a value.
         */
        "errortype"?: | 'badInput'
    | 'customError'
    | 'patternMismatch'
    | 'rangeOverflow'
    | 'rangeUnderflow'
    | 'stepMismatch'
    | 'tooLong'
    | 'tooShort'
    | 'typeMismatch'
    | 'valid'
    | 'valueMissing'
    | undefined;
        /**
          * Whether the input is focused or not.
         */
        "isFocused"?: boolean;
        /**
          * Floating label for the input.
         */
        "label"?: string;
        /**
          * Fired when the new value is valid.
         */
        "onValueChanged"?: (event: InnoInputCustomEvent<string | number>) => void;
        /**
          * Set the resize direction. Only has effect if textarea is provided as wrapped element.
         */
        "resizeMode"?: 'vertical' | 'horizontal' | 'both';
        /**
          * Whether the textarea is resizeable. Only has effect if textarea is provided as wrapped element.
         */
        "resizeable"?: boolean;
        /**
          * When you click on the inno-input a focus() command is called on the input element. This might cause that the caret position will be at the beginnging of the input's value. Set this to true if you want to select all of the text by default.
         */
        "selectOnFocus"?: boolean;
        "valuePropReDefine"?: boolean;
        /**
          * Color variant of the input.
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoLoader {
        /**
          * Size of the loader. Valid values are: 16, 24, 32, 64.
         */
        "size"?: number;
        /**
          * Loader bar width.
         */
        "strokeWidth"?: 'thin' | 'thick';
        /**
          * Theme variant property.
         */
        "variant"?: 'light' | 'dark';
    }
    /**
     * Represents the main frame of the modal component.
     */
    interface InnoModal {
        /**
          * Should the modal be animated
         */
        "animation"?: boolean;
        /**
          * Show a backdrop behind the modal dialog
         */
        "backdrop"?: boolean;
        /**
          * Centered modal
         */
        "centered"?: boolean;
        /**
          * Dismiss modal on backdrop click
         */
        "closeOnBackdropClick"?: boolean;
        /**
          * If set to true the modal can be closed by pressing the Escape key
         */
        "closeOnEscape"?: boolean;
        /**
          * By default the modal always opens at the top and the InnoModal component automatically scrolls to it. Set this to true if you want the modal to be always in a fixed position no matter where you scroll.
         */
        "fixed"?: boolean;
        /**
          * Dialog close
         */
        "onDialogClose"?: (event: InnoModalCustomEvent<any>) => void;
        /**
          * Dialog cancel
         */
        "onDialogDismiss"?: (event: InnoModalCustomEvent<any>) => void;
        /**
          * Modal size
         */
        "size"?: InnoModalSize;
        /**
          * Theme variant of the component.
         */
        "variant"?: 'dark' | 'light';
    }
    /**
     * Represents the main content of the modal.
     * The content is provided by the user.
     * See the inno-modal component for more information.
     */
    interface InnoModalContent {
    }
    /**
     * Represents the footer content for the InnoModal component.
     * See the inno-modal component for more information.
     */
    interface InnoModalFooter {
    }
    /**
     * Represents the header of the inno-modal component.
     * See the inno-modal component for more information.
     */
    interface InnoModalHeader {
        /**
          * Icon of the header, optional.
         */
        "icon"?: string;
        /**
          * Emits when close icon is clicked and closes the modal Can be prevented, in which case only the event is triggered, and the modal remains open
         */
        "onCloseClick"?: (event: InnoModalHeaderCustomEvent<Event>) => void;
        /**
          * Hide the close button.
         */
        "showClose"?: boolean;
        /**
          * Theme variant of the component.
         */
        "variant"?: 'dark' | 'light';
    }
    interface InnoPaginator {
        /**
          * Item count change event
         */
        "onItemCountChanged"?: (event: InnoPaginatorCustomEvent<number>) => void;
        /**
          * Page selection event
         */
        "onPageSelected"?: (event: InnoPaginatorCustomEvent<number>) => void;
        /**
          * Total number of pages
         */
        "pageCount"?: number;
        /**
          * One based index of currently selected page
         */
        "selectedPage"?: number;
        "variant"?: 'dark' | 'light';
    }
    interface InnoPane {
        /**
          * Whether the pane is closeable by clicking outside of it.
         */
        "closeOnBackdropClick"?: boolean;
        /**
          * Programatically control whether the pane is opened or closed.
         */
        "expanded"?: boolean;
        /**
          * The pane comes with a close button by default. Hide it with this property.
         */
        "hideCloseButton"?: boolean;
        /**
          * This event is fired when the pane is opened or closed.
         */
        "onExpandedChanged"?: (event: InnoPaneCustomEvent<ExpandedChangedEvent>) => void;
        /**
          * Size of the pane. It is a width value in case of 'left' and 'right' position, and a height value in case of 'top' and 'bottom' position.  All css units are supported which are supported by width and height css properties.
         */
        "paneSize"?: string;
        /**
          * Position of the pane.
         */
        "position"?: 'top' | 'left' | 'bottom' | 'right';
        /**
          * Title of the pane.
         */
        "titleText"?: string;
    }
    interface InnoPopover {
        "animationFrame"?: boolean;
        /**
          * Popover will have a close button. Has no effect if trigger type is 'hover'.
         */
        "closable"?: boolean;
        /**
          * Css selector of the element the popover is for. This is just the initial value,  don't update it manually. Use the 'updateForElement(...)' method instead.
         */
        "for"?: string;
        /**
          * Popover should have a backdrop. Has no effect if trigger type is 'hover'.
         */
        "hasBackdrop"?: boolean;
        /**
          * Offset of the popover position in pixels. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "offset"?: number;
        /**
          * Fired when popover is hidden.
         */
        "onInnoPopoverHidden"?: (event: InnoPopoverCustomEvent<void>) => void;
        /**
          * Fired when popover is shown.
         */
        "onInnoPopoverShown"?: (event: InnoPopoverCustomEvent<void>) => void;
        /**
          * Position of the popover. If there is not enough space it will be automatically placed to where it has enough place. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "placement"?: Placement;
        /**
          * Contents of the text. Can be either html or a simple string. Can be omitted. You can use this property if you want a simple tooltip,  otherwise you can provide your own html directly.
         */
        "popoverText"?: string;
        /**
          * Contents of the title. Can be either html or a simple string. Can be omitted.
         */
        "popoverTitle"?: string;
        /**
          * How to show the popover. If set to 'manual' then you need to programatically modify the 'visibile' property.
         */
        "trigger"?: 'hover' | 'click' | 'manual';
        /**
          * Color variant of the popover.
         */
        "variant"?: 'light' | 'dark';
        /**
          * Programatically change whether the popover is visible or not.
         */
        "visible"?: boolean;
    }
    interface InnoProgressBar {
        /**
          * If the percentage number is shown, how many decimal places should be visible
         */
        "percentagePrecision"?: number;
        /**
          * Progress in percentage. Must be a number between 0 and 100.
         */
        "progressPercentage"?: number;
        /**
          * Text to display for the progress bar.
         */
        "progressText"?: string;
        /**
          * Show the percentage number on the progress bar. The value is rounded according to the 'percentagePrecision' and 'trailingZeroes' properties.
         */
        "showPercentage"?: boolean;
        /**
          * If 'percentagePrecision' is larger than 0, should we display the trailing zeroes. For example if the progress is 1.5% and the 'percentagePrecision' is 2 then the displayed text will be '1.50%'  if trailing zeroes are enabled and '1.5%' if trailing zeroes are disabled. Uses the toFixed(..) function in the background.
         */
        "trailingZeroes"?: boolean;
        /**
          * Color variant of the progress bar.
         */
        "variant"?: 'light' | 'dark';
    }
    /**
     * Represents the default radio button for the Innomics applications.
     */
    interface InnoRadio {
        "checked"?: boolean;
        /**
          * Whether component is disabled. In this state no other state effects are applied to the element like error.
         */
        "disabled"?: boolean;
        /**
          * Whether the element is in error state. Error state can be defined if manual error handling is required.
         */
        "error"?: boolean;
        /**
          * Label to show.
         */
        "label"?: string;
        /**
          * Form entry group name.
         */
        "name"?: string;
        /**
          * Emits the associated value when the element is clicked.
         */
        "onValueChange"?: (event: InnoRadioCustomEvent<string>) => void;
        /**
          * Whether the component is readonly. In this state no other state effects are applied to the element like error.
         */
        "readonly"?: boolean;
        /**
          * Mark the component as required and show the required marker. Validation is performed with this property.
         */
        "required"?: boolean;
        /**
          * The tab index.
         */
        "tabIdx"?: number;
        /**
          * Radio button value.
         */
        "value"?: string;
        /**
          * Theme variant of the component.
         */
        "variant"?: 'dark' | 'light';
    }
    interface InnoSelect {
        /**
          * The floating label is an absolutely positioned element meaning if it is too long it will grow out of the boundaries of the InnoSelect component. By default the InnoSelect component automatically resizes the floating label so it will fit inside. You can turn this behavior off e.g. if you are sure the label will always fit or it causes some issues.
         */
        "disableFloatingLabelAutoResize"?: boolean;
        /**
          * Whether the select is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * By default the InnoSelect component automatically resizes the dropdown so it will be as wide as the component itself. You can override it to be a fixed width. Accepts any value that the 'width' css property accepts, e.g. "300px" or "min-content"
         */
        "dropdownWidth"?: string;
        /**
          * Icon for select when no item selected When icon is present the label is not behaves as floating
         */
        "icon"?: string;
        /**
          * If you work with object arrays you can set a simple function which returns the unique key value  so the objects can be differentiated. By default we assume you work with simple arrays so we simply return the value as it is, in that case you don't have to provide this function.
         */
        "keyValueSelector"?: (val: any) => any;
        /**
          * Label for the select when no item selected.
         */
        "label"?: string;
        /**
          * This event is fired when the dropdown is closed. You can use this event for example  if you want to reorder your InnoSelectItems after the favorited elements are changed.
         */
        "onDropdownClosed"?: (event: InnoSelectCustomEvent<void>) => void;
        /**
          * This event is fired when an item is added to or removed from favorites. The event contains all of the favorited items.
         */
        "onFavoriteItemsChanged"?: (event: InnoSelectCustomEvent<any>) => void;
        /**
          * This event is fired when an item is favorited. You have to take care of managing and ordering the array of favorite items in your business logic.
         */
        "onItemIsFavorited"?: (event: InnoSelectCustomEvent<any>) => void;
        /**
          * This event is fired when an item is removed from favorites. You have to take care of managing and ordering the array of favorite items in your business logic.
         */
        "onItemIsUnfavorited"?: (event: InnoSelectCustomEvent<any>) => void;
        /**
          * This event is fired when the value changes.
         */
        "onValueChanged"?: (event: InnoSelectCustomEvent<string>) => void;
        /**
          * Value of the select.
         */
        "value"?: any;
        /**
          * Color variant of the select.
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoSelectItem {
        /**
          * Tooltip text for favorite add. The tooltip is only visible if the InnoSelectItem has a unique id.
         */
        "addToFavoritesLabel"?: string;
        /**
          * Adds a favorite icon to the selectable item. If you press this icon an event will be fired with the selected item.  You have to take care of managing and ordering the array of favorite items in your business logic. Clicking on the favorite icon will not close the dropdown.
         */
        "canFavorite"?: boolean;
        /**
          * Offset of the favorite icon tooltip position in pixels. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "favoriteIconTooltipOffset"?: number;
        /**
          * Position of the favorite icon tooltip. Please note that the offset will remain the same in case the desired placement does not fit.
         */
        "favoriteIconTooltipPos"?: Placement;
        /**
          * Color variant of the favorite icon tooltip.
         */
        "favoriteIconTooltipVariant"?: 'light' | 'dark';
        /**
          * A simple separator for the item. You can use it for example to visually separate the favorited and non-favorited items.
         */
        "hasSeparator"?: boolean;
        /**
          * Optional icon for the label.
         */
        "icon"?: string;
        /**
          * The selectable item is favorited or not.
         */
        "isFavorite"?: boolean;
        /**
          * Label of the item, can be different from the value.
         */
        "label"?: string;
        /**
          * This event is fired whenever an item is favorited.
         */
        "onItemFavorited"?: (event: InnoSelectItemCustomEvent<any>) => void;
        /**
          * This event is fired whenever the selected item's label changes. The inno-select component then will rerender.
         */
        "onItemLabelChanged"?: (event: InnoSelectItemCustomEvent<any>) => void;
        /**
          * This event is fired whenever an item is selected.
         */
        "onItemSelected"?: (event: InnoSelectItemCustomEvent<any>) => void;
        /**
          * This event is fired whenever an item is removed from favorites.
         */
        "onItemUnfavorited"?: (event: InnoSelectItemCustomEvent<any>) => void;
        /**
          * Tooltip text for favorite remove. The tooltip is only visible if the InnoSelectItem has a unique id.
         */
        "removeFromFavoritesLabel"?: string;
        /**
          * Whether the item is selected or not.
         */
        "selected"?: boolean;
        /**
          * Value of the item.
         */
        "value"?: any;
    }
    /**
     * Represents a status message entry.
     */
    interface InnoStatusMessage {
        /**
          * Autoclose message after the given delay. The message will be closed independently from showProgress property.
         */
        "autoClose"?: boolean;
        /**
          * Autoclose delay.
         */
        "autoCloseDelay"?: number;
        /**
          * Icon of toast
         */
        "icon"?: string;
        /**
          * Icon color of toast
         */
        "iconColor"?: string;
        /**
          * Type of the status message.
         */
        "messageType"?: InnoStatusMessageType;
        /**
          * Status message is closed.
         */
        "onCloseMessage"?: (event: InnoStatusMessageCustomEvent<any>) => void;
        /**
          * Animate progressbar and close after animation ends. The message will be closed independently from autoClose property.
         */
        "showProgress"?: boolean;
        /**
          * Theme variant of the component.
         */
        "theme"?: InnoStatusMessageTheme;
    }
    /**
     * Container to hold the status messages.
     */
    interface InnoStatusMessageContainer {
        /**
          * Customizable container class.
         */
        "containerClass"?: string;
        /**
          * Customizable container id.
         */
        "containerId"?: string;
        /**
          * Position of container.
         */
        "position"?: InnoStatusMessagePosition;
    }
    interface InnoTab {
        /**
          * Make the non-selected items always vivid without any opacity effect.
         */
        "alwaysEmphasized"?: boolean;
        /**
          * Set layout width style
         */
        "layout"?: 'auto' | 'stretched';
        /**
          * Minimalize the bottom decorator for the tab items. Show only if the given item is interracted or selected.
         */
        "minimalDecorator"?: boolean;
        /**
          * `selected` property changed
         */
        "onSelectedChange"?: (event: InnoTabCustomEvent<number>) => void;
        /**
          * Set default selected tab by index or undefined if not tab is selected.
         */
        "selected"?: number | undefined;
        /**
          * Show the navigation arrow for desktop.
         */
        "showArrow"?: boolean;
        /**
          * Theme variant of the component.
         */
        "theme"?: 'light' | 'dark';
    }
    /**
     * Represents an inno-tab item.
     * Wraps the provided content.
     * See the InnoTab component for more information about how to use the tab component.
     */
    interface InnoTabItem {
        /**
          * Make the non-selected items always vivid without any opacity effect.
         */
        "alwaysEmphasized"?: boolean;
        /**
          * Set disabled tab.
         */
        "disabled"?: boolean;
        /**
          * Set layout width style. Auto: Item has the same width as the enclosed item in slot. Stretched: Item has the maximum available width.
         */
        "layout"?: 'auto' | 'stretched';
        /**
          * Minimalize the bottom decorator for the tab items. Show only if the given item is interracted or selected.
         */
        "minimalDecorator"?: boolean;
        /**
          * On tab click.
         */
        "onTabClick"?: (event: InnoTabItemCustomEvent<TabClickDetail>) => void;
        /**
          * Set selected tab.
         */
        "selected"?: boolean;
        /**
          * Theme variant property. Inherited from the parent. Can be overridden if explicitly defined.
         */
        "theme"?: 'light' | 'dark';
    }
    /**
     * Basic wrapper element for html tables. Adds some basic styling to the table and a custom scrollbar with fade-out effect.
     * Can be used without html table as well, in that case only the custom scrollbar with fade-out effect will be applied to the html element.
     */
    interface InnoTableBase {
        /**
          * The fade-out effect while scrolling is achieved by using mask-image and linear-gradient.  For it to work properly a color must be set to be the same as the table's background color.
         */
        "maskColor"?: string;
        /**
          * Color variant of the table;
         */
        "variant"?: 'light' | 'dark';
    }
    interface InnoTimePicker {
        /**
          * Date format string. See "https://moment.github.io/luxon/#/formatting?id=table-of-tokens" for all available tokens.
         */
        "format"?: string;
        "onValueChange"?: (event: InnoTimePickerCustomEvent<any>) => void;
        /**
          * Component text configuration.
         */
        "texts"?: InnoTimePickerTexts | undefined;
        /**
          * Theme variant of the component.
         */
        "theme"?: 'light' | 'dark';
        "time"?: string | undefined;
    }
    interface InnoToggle {
        /**
          * Whether the slide-toggle element is checked or not. Can be changed programatically, will emit a change event.
         */
        "checked"?: boolean;
        /**
          * Whether the slide-toggle element is disabled or not.
         */
        "disabled"?: boolean;
        /**
          * An event will be dispatched each time the slide-toggle changes its value.
         */
        "onCheckedChange"?: (event: InnoToggleCustomEvent<boolean>) => void;
        /**
          * The tab index of the toggle
         */
        "tabIdx"?: number;
        /**
          * Color variant of the toggle component.
         */
        "variant"?: 'dark' | 'light';
    }
    interface IntrinsicElements {
        "inno-accordion": InnoAccordion;
        "inno-breadcrumb": InnoBreadcrumb;
        "inno-breadcrumb-item": InnoBreadcrumbItem;
        "inno-button": InnoButton;
        "inno-checkbox": InnoCheckbox;
        "inno-date-picker": InnoDatePicker;
        "inno-date-picker-dropdown": InnoDatePickerDropdown;
        "inno-date-time-card": InnoDateTimeCard;
        "inno-drag-and-drop": InnoDragAndDrop;
        "inno-error": InnoError;
        "inno-footer": InnoFooter;
        "inno-footer-item": InnoFooterItem;
        "inno-icon": InnoIcon;
        "inno-input": InnoInput;
        "inno-loader": InnoLoader;
        "inno-modal": InnoModal;
        "inno-modal-content": InnoModalContent;
        "inno-modal-footer": InnoModalFooter;
        "inno-modal-header": InnoModalHeader;
        "inno-paginator": InnoPaginator;
        "inno-pane": InnoPane;
        "inno-popover": InnoPopover;
        "inno-progress-bar": InnoProgressBar;
        "inno-radio": InnoRadio;
        "inno-select": InnoSelect;
        "inno-select-item": InnoSelectItem;
        "inno-status-message": InnoStatusMessage;
        "inno-status-message-container": InnoStatusMessageContainer;
        "inno-tab": InnoTab;
        "inno-tab-item": InnoTabItem;
        "inno-table-base": InnoTableBase;
        "inno-time-picker": InnoTimePicker;
        "inno-toggle": InnoToggle;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "inno-accordion": LocalJSX.InnoAccordion & JSXBase.HTMLAttributes<HTMLInnoAccordionElement>;
            "inno-breadcrumb": LocalJSX.InnoBreadcrumb & JSXBase.HTMLAttributes<HTMLInnoBreadcrumbElement>;
            "inno-breadcrumb-item": LocalJSX.InnoBreadcrumbItem & JSXBase.HTMLAttributes<HTMLInnoBreadcrumbItemElement>;
            "inno-button": LocalJSX.InnoButton & JSXBase.HTMLAttributes<HTMLInnoButtonElement>;
            /**
             * Checkbox for Innomatics design system.
             */
            "inno-checkbox": LocalJSX.InnoCheckbox & JSXBase.HTMLAttributes<HTMLInnoCheckboxElement>;
            /**
             * Innomotics date-picker.
             */
            "inno-date-picker": LocalJSX.InnoDatePicker & JSXBase.HTMLAttributes<HTMLInnoDatePickerElement>;
            /**
             * Date-picker with dropdown.
             */
            "inno-date-picker-dropdown": LocalJSX.InnoDatePickerDropdown & JSXBase.HTMLAttributes<HTMLInnoDatePickerDropdownElement>;
            "inno-date-time-card": LocalJSX.InnoDateTimeCard & JSXBase.HTMLAttributes<HTMLInnoDateTimeCardElement>;
            "inno-drag-and-drop": LocalJSX.InnoDragAndDrop & JSXBase.HTMLAttributes<HTMLInnoDragAndDropElement>;
            "inno-error": LocalJSX.InnoError & JSXBase.HTMLAttributes<HTMLInnoErrorElement>;
            /**
             * Represents the general footer for the Innomotics applications.
             */
            "inno-footer": LocalJSX.InnoFooter & JSXBase.HTMLAttributes<HTMLInnoFooterElement>;
            /**
             * Represents an inno-footer item.
             * Wrap an element for the inno-footer parent.
             * See the InnoFooter docs for more information.
             */
            "inno-footer-item": LocalJSX.InnoFooterItem & JSXBase.HTMLAttributes<HTMLInnoFooterItemElement>;
            "inno-icon": LocalJSX.InnoIcon & JSXBase.HTMLAttributes<HTMLInnoIconElement>;
            "inno-input": LocalJSX.InnoInput & JSXBase.HTMLAttributes<HTMLInnoInputElement>;
            "inno-loader": LocalJSX.InnoLoader & JSXBase.HTMLAttributes<HTMLInnoLoaderElement>;
            /**
             * Represents the main frame of the modal component.
             */
            "inno-modal": LocalJSX.InnoModal & JSXBase.HTMLAttributes<HTMLInnoModalElement>;
            /**
             * Represents the main content of the modal.
             * The content is provided by the user.
             * See the inno-modal component for more information.
             */
            "inno-modal-content": LocalJSX.InnoModalContent & JSXBase.HTMLAttributes<HTMLInnoModalContentElement>;
            /**
             * Represents the footer content for the InnoModal component.
             * See the inno-modal component for more information.
             */
            "inno-modal-footer": LocalJSX.InnoModalFooter & JSXBase.HTMLAttributes<HTMLInnoModalFooterElement>;
            /**
             * Represents the header of the inno-modal component.
             * See the inno-modal component for more information.
             */
            "inno-modal-header": LocalJSX.InnoModalHeader & JSXBase.HTMLAttributes<HTMLInnoModalHeaderElement>;
            "inno-paginator": LocalJSX.InnoPaginator & JSXBase.HTMLAttributes<HTMLInnoPaginatorElement>;
            "inno-pane": LocalJSX.InnoPane & JSXBase.HTMLAttributes<HTMLInnoPaneElement>;
            "inno-popover": LocalJSX.InnoPopover & JSXBase.HTMLAttributes<HTMLInnoPopoverElement>;
            "inno-progress-bar": LocalJSX.InnoProgressBar & JSXBase.HTMLAttributes<HTMLInnoProgressBarElement>;
            /**
             * Represents the default radio button for the Innomics applications.
             */
            "inno-radio": LocalJSX.InnoRadio & JSXBase.HTMLAttributes<HTMLInnoRadioElement>;
            "inno-select": LocalJSX.InnoSelect & JSXBase.HTMLAttributes<HTMLInnoSelectElement>;
            "inno-select-item": LocalJSX.InnoSelectItem & JSXBase.HTMLAttributes<HTMLInnoSelectItemElement>;
            /**
             * Represents a status message entry.
             */
            "inno-status-message": LocalJSX.InnoStatusMessage & JSXBase.HTMLAttributes<HTMLInnoStatusMessageElement>;
            /**
             * Container to hold the status messages.
             */
            "inno-status-message-container": LocalJSX.InnoStatusMessageContainer & JSXBase.HTMLAttributes<HTMLInnoStatusMessageContainerElement>;
            "inno-tab": LocalJSX.InnoTab & JSXBase.HTMLAttributes<HTMLInnoTabElement>;
            /**
             * Represents an inno-tab item.
             * Wraps the provided content.
             * See the InnoTab component for more information about how to use the tab component.
             */
            "inno-tab-item": LocalJSX.InnoTabItem & JSXBase.HTMLAttributes<HTMLInnoTabItemElement>;
            /**
             * Basic wrapper element for html tables. Adds some basic styling to the table and a custom scrollbar with fade-out effect.
             * Can be used without html table as well, in that case only the custom scrollbar with fade-out effect will be applied to the html element.
             */
            "inno-table-base": LocalJSX.InnoTableBase & JSXBase.HTMLAttributes<HTMLInnoTableBaseElement>;
            "inno-time-picker": LocalJSX.InnoTimePicker & JSXBase.HTMLAttributes<HTMLInnoTimePickerElement>;
            "inno-toggle": LocalJSX.InnoToggle & JSXBase.HTMLAttributes<HTMLInnoToggleElement>;
        }
    }
}
